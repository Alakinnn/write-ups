Most hashing algorithms produce hashes of a constant length. The length of a particular hash can be used to map it to the algorithm it was hashed with. For example, a hash of 32 characters in length can be an MD5 or NTLM hash.

Sometimes, hashes are stored in certain formats. For example, `hash:salt` or `$id$salt$hash`.

The hash `2fc5a684737ce1bf7b3b239df432416e0dd07357:2014` is a SHA1 hash with the salt of `2014`.

The hash `$6$vb1tLY1qiY$M.1ZCqKtJBxBtZm1gRi8Bbkn39KU0YJW1cuMFzTRANcNKFKR4RmAQVk4rqQQCkaJT6wXqjUkFcA/qNxLyqW.U/` contains three fields delimited by `$`, where the first field is the `id`, i.e., `6`.

```shell-session
$1$  : MD5
$2a$ : Blowfish
$2y$ : Blowfish, with correct handling of 8 bit characters
$5$  : SHA256
$6$  : SHA512
```

The next field, `vb1tLY1qiY`, is the salt used during hashing, and the final field is the actual hash.

Open and closed source software use many different kinds of hash formats. For example, the `Apache` web server stores its hashes in the format `$apr1$71850310$gh9m4xcAn3MGxogwX/ztb.`, while `WordPress` stores hashes in the form `$P$984478476IagS59wHZvyQMArzfx58u.`



## Hashid

[Hashid](https://github.com/psypanda/hashID) is a `Python` tool, which can be used to detect various kinds of hashes. At the time of writing, `hashid` can be used to identify over 200 unique hash types, and for others, it will make a best-effort guess, which will still require some additional work to narrow it down. The full list of supported hashes can be found [here](https://github.com/psypanda/hashID/blob/master/doc/HASHINFO.xlsx). It can be installed using `pip`.

```shell-session
alakin2504@htb[/htb]$ hashid '$apr1$71850310$gh9m4xcAn3MGxogwX/ztb.'

Analyzing '$apr1$71850310$gh9m4xcAn3MGxogwX/ztb.'
[+] MD5(APR) 
[+] Apache MD5
```

If known, `hashid` can also provide the corresponding `Hashcat` hash mode with the `-m` flag if it is able to determine the hash type.

```shell-session
alakin2504@htb[/htb]$ hashid '$DCC2$10240#tom#e4e938d12fe5974dc42a90120bd9c90f' -m
Analyzing '$DCC2$10240#tom#e4e938d12fe5974dc42a90120bd9c90f'
[+] Domain Cached Credentials 2 [Hashcat Mode: 2100
```

---

## Context is Important

It is not always possible to identify the algorithm based on the obtained hash. Depending on the software, the plaintext might undergo multiple encryption rounds and salting transformations, making it harder to recover.

It is important to note that `hashid` uses regex to make a best-effort determination for the type of hash provided. Oftentimes `hashid` will provide many possibilities for a given hash, and we will still be left with a certain amount of guesswork to identify a given hash. This may happen during a CTF, but we usually have some context around the type of hash we are looking to identify during a penetration test. Was it obtained via an Active Directory attack or from a Windows host? Was it obtained through the successful exploitation of a SQL injection vulnerability? Knowing where a hash came from will greatly help us narrow down the hash type and, therefore, the `Hashcat` hash mode necessary to attempt to crack it.

For example, passing the hash `a2d1f7b7a1862d0d4a52644e72d59df5:500:lp@trash-mail.com` to `hashid` will give us various possibilities:

```shell-session
alakin2504@htb[/htb]$ hashid 'a2d1f7b7a1862d0d4a52644e72d59df5:500:lp@trash-mail.com'

Analyzing 'a2d1f7b7a1862d0d4a52644e72d59df5:500:lp@trash-mail.com'
[+] MD5 
[+] MD4 
[+] Double MD5 
[+] LM 
[+] RIPEMD-128 
[+] Haval-128 
[+] Tiger-128 
[+] Skein-256(128) 
[+] Skein-512(128) 
[+] Lotus Notes/Domino 5 
[+] Skype 
[+] Lastpass 
```

However, a quick look through the `Hashcat` example hashes reference will help us determine that it is indeed a Lastpass hash, which is hash mode `6800`.